#!/usr/bin/env python
import rospy
from sensor_msgs.msg import Joy
from time import sleep
import serial
import math

# ser = serial.Serial('/dev/ttyACM0', 115200)

# Author: parker, steve, callum
# This ROS Node selects/converts inputs from the joy_node

def callback(data): # Receives joystick messages subscribed to Joy topic
    WIDTH = 25
    LENGTH = 26.5
    SIDE = 25.75  # average the two for now
    WHEELRADIUS = 4.0  # with orange tread
    yAxis = data.axes[1] * 200
    xAxis = data.axes[0] * 200 * -1  # puts pospos quadrant in upperright
    angular = data.axes[2] * 90

    speed = math.sqrt(yAxis * yAxis + xAxis * xAxis)
    try:
        bearing = math.atan(xAxis / yAxis)  # we do adj/opp here since we want zero degrees to be across the yAxis
        bearing = bearing * 57.2958  # convert radians to degrees
        bearing = math.fabs(bearing)  # convert to pos
        if yAxis < 0:  # sort out the bearing and quadrants
            if xAxis < 0:
                print
                'oldbearing' + str(bearing)
                bearing = (bearing - 180) * -1
                quadrant = 3
            else:
                bearing = 180 - bearing
                if xAxis == 0:
                    quadrant = 0
                else:
                    quadrant = 4
        else:
            if xAxis < 0:
                quadrant = 2
            else:
                if xAxis == 0:
                    quadrant = 0
                else:
                    quadrant = 1
    except ZeroDivisionError:
        # determine if on x or y
        if xAxis == 0:
            bearing = 0
        else:
            quadrant = 0
            if yAxis > 1:
                bearing = -90
            else:
                bearing = 90

    print
    'angular' + str(angular)
    print
    'newbearing' + str(bearing)
    print
    'speed' + str(speed)
    print
    'yAxis' + str(yAxis)
    print
    'xAxis' + str(xAxis)
    try:
        print
        'quadrant' + str(quadrant)
    except UnboundLocalError:
        print
        'quadrantNULL'

def calcWheel(speed, vel_vector, theta_dot): # Calculate wheel_theta and wheel_speed with direction
    RADIANS = 0.0174533 # Conversion for radians; 2pi/360
    wheel_theta # Angle of wheels, calcualted from vv + delta theta
    wheel_speed = math.fabs(theta_dot)*robot_radius*RADIANS
    robot_radius = 46.2 # Radius from wheel to center of bender in centimeters
    rot_speed # Rotational speed of the robot at the individual wheel
    delta_theta # Change in wheel theta due to rotational speed
    angle_vv_rot # Angle between the velocity vectors and rotational speed vector at the wheel
    comp_angle # Complementary angle of angle_vv_rot

    if math.fabs(speed) < 5: # If no translational speed
        if math.fabs(rot_speed) > 0.001: # If some rotational speed
            wheel_theta = wheel_theta_no_speed
            wheel_speed = rot_speed
    else:
        if math.fabs(rot_speed) < 0.001: # Set theta and speed if only translational speed
            wheel_theta = vel_vector
            wheel_speed = speed
        else: # Attempt to determine angle bewteen vv and rot vector at wheel
            if theta_dot < 0:
                angle_vv_rot = wheel_psi - vel_vect - 90
            else:
                angle_vv_rot = wheel_psi - vel_vect + 90
            comp_angle = 180 - angle_vv_rot

            if(comp_angle > 180): # Attempt to find complimentary angle for equation
                comp_angle = comp_angle - 360
            elif comp_angle < -180:
                comp_angle = comp_angle + 360
            # Determine delta theta or angle of resultant vector from speed vector
            wheel_speed = math.sqrt(math.pow(speed, 2)+math.pow(rot_speed, 2)-2*speed*rot_speed*math.cos(comp_angle)) # Determine wheel speed
            delta_theta = math.asin((math.sin(comp_angle)*speed)/wheel_speed)
            wheel_theta = vel_vector + delta_theta
    if wheel_theta > 180:
        wheel_theta = wheel_theta - 360
    elif wheel_theta < 180:
        wheel_theta = wheel_theta + 360
    if(math.abs(current_wheel_theta - wheel_theta) > 90):
        speed = speed * -1
        if wheel_theta < 0:
            wheel_theta = wheel_theta + 180
        else:
            wheel_theta = wheel_theta - 180
    return wheel_theta, wheel_speed

def start():
    rospy.Subscriber("joy", Joy, callback)
    rospy.init_node('Joy2BenderBitches')
    rospy.spin()

if __name__ == '__main__':
    start()



